model BookingSys

-- main control class

class BookingSystem
  
  operations      
    selectBooking(tno: Integer, hr: Integer, mn: Integer)
    begin      
        for r in self.current do
          if (r.table.tno = tno and r.getTime() = hr*60+mn) then
            insert(self,r) into Selected                
          end
        end
    end

    unSelectBooking()
    begin
      delete (self,self.selected) from Selected
    end
    
    recordArrival(hr: Integer, mn: Integer)
    begin
        declare t: Time;
        t := new Time; 
        t.setTime(hr, mn);
        self.selected.setArrivalTime(t);
        WriteLine('Customer has just been seated ');
        self.selected.showDetails()
    end

    cancelReservation()
    begin
        Write('The booking made by ');
        self.selected.getCustomerName();
        WriteLine(' was cancelled');
        destroy self.selected
    end
	
    -- version of cancel not defined in SOIL
    cancel(r : Reservation)

    statemachines
        psm States
        states                        
            newBooking : initial
            notSelected
            selected
        transitions
            newBooking ->  notSelected  { create }
            notSelected -> selected { selectBooking() }
            selected -> selected { [self.selected.table.covers >= self.selected.covers] recordArrival() }
            selected -> selected { selectBooking() }
            selected -> notSelected { unSelectBooking() }
            selected -> notSelected { cancelReservation() }
            notSelected -> notSelected { cancel() }
        end
    end


class Booking
  attributes
    covers : Integer
    time : Time

  operations
    setArrivalTime(t: Time)
    begin
    end
    
    showDetails()
    begin
    end

    getCustomerName()
    begin
    end
    
    setTime(t : Time)
    begin
        self.time := t
    end 

  
    -- A query operation to retun the time of the booking in minutes
    getTime() : Integer = time.getTime()
end

class WalkIn < Booking
  attributes
    arrivalTime : Time
  operations
    recordArrival()
    begin
      Write('Selected walkin is by');
    
    end

  setArrivalTime(t: Time)
    begin
        self.arrivalTime := t
    end
    

    statemachines
		psm States
		states
			newWalkIn : initial
			waiting
			seated
		transitions
			newWalkIn -> waiting { create }
			waiting -> seated { recordArrival() }
		end

end


class Reservation < Booking
  attributes
    arrivalTime : Time
  operations
    showDetails()
    begin
        Write('Selected reservation is by ');
        WriteLine(self.customer.name)
    end
    
    setArrivalTime(t : Time)
    begin
        self.arrivalTime := t
    end
    
    setCustomer(c : Customer) 
    begin
        insert(c, self) into Makes        
    end

    setCovers(cv : Integer)
    begin
      self.covers := cv
    end

    getCustomerName()
    begin
      Write(self.customer.name)
    end
	
	statemachines
		psm States
		states
			newReservation : initial
			waiting
			seated
		transitions
			newReservation -> waiting { create }
			waiting -> seated { setArrivalTime() }
		end
end


class Customer
  attributes
    name : String
    phoneNumber : String
  operations
    makeReservation(covers : Integer, table : Table, bookingHr : Integer, bookingMin : Integer)
    begin
      declare time : Time, reservation : Reservation;
      time := new Time;
      time.setTime(bookingHr, bookingMin);

      reservation := new Reservation;
      reservation.setCovers(covers);
      reservation.setTime(time);
      reservation.setCustomer(self);

      --insert(bs, reservation) into Contains;
      insert(reservation, table) into IsAt;

      WriteLine('Reservation made successfully.');
    end

    walkIn()
    begin
    end
end


class Table 
  attributes
    tno : Integer
    covers : Integer
    
  statemachines
    psm States
    states
      newTable : initial
      available
      reserved
      occupied
    transitions
      newTable -> available { create }
      --available -> reserved { }
    end
end


class Time
  attributes
    hour : Integer
    min : Integer
  operations
    setTime(h: Integer, m: Integer)
    begin
        self.hour := h;
        self.min := m
    end 
    
    -- a query method to return the time since midnight in minutes
    getTime() : Integer = self.hour*60 + self.min      
end   

association IsAt between 
    Booking[*] role bookings
    Table[1]
end

association Makes between
    Customer[1]
    Reservation[*] role reservations
end

association Arrive between
    Customer[1]
    WalkIn[*] role WalkIns
end

association Contains between
    BookingSystem[1] role bs
    Booking[*] role current
end

association Selected between
    BookingSystem[1] role bsys
    Booking[0..1] role selected
end


constraints

context BookingSystem::recordArrival(hr: Integer, mn: Integer)
    pre arrivalBeforeBooking: self.selected.getTime() <= mn + hr*60

context BookingSystem::cancel(r : Reservation)
    pre Pre1: current->includes(r)
    post Post1: current->excludes(r)

context Table
  inv noOverlap: self.bookings->forAll(b1, b2 | b1.getTime() + 120 <= b2.getTime() or b2.getTime() + 120 <= b1.getTime())

context BookingSystem
  inv mustBeOneOf: not self.selected.isDefined() or self.current->includes(self.selected)





